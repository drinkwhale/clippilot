# YouTube 영상 검색 기능 - 데이터 모델

## 개요

이 문서는 YouTube 영상 검색 기능에서 사용되는 모든 데이터 구조, DB 스키마, API 타입 정의를 포함합니다.

---

## 1. Database Schema

### 1.1 templates 테이블 확장

기존 `templates` 테이블에 YouTube 관련 컬럼 추가:

```sql
-- Migration: xxx_add_youtube_columns_to_templates.sql
ALTER TABLE templates
ADD COLUMN youtube_video_id VARCHAR(20),
ADD COLUMN youtube_metadata JSONB,
ADD COLUMN captions JSONB,
ADD COLUMN cii_score DECIMAL(5,2),
ADD COLUMN channel_info JSONB;

-- 인덱스 추가
CREATE INDEX idx_templates_youtube_video_id ON templates(youtube_video_id);
CREATE INDEX idx_templates_cii_score ON templates(cii_score) WHERE cii_score IS NOT NULL;

-- 제약조건 추가
ALTER TABLE templates
ADD CONSTRAINT chk_cii_score_range CHECK (cii_score >= 0 AND cii_score <= 100);

-- 코멘트 추가
COMMENT ON COLUMN templates.youtube_video_id IS 'YouTube 영상 ID (예: dQw4w9WgXcQ)';
COMMENT ON COLUMN templates.youtube_metadata IS 'YouTube 영상 메타데이터 (제목, 설명, 태그, 통계 등)';
COMMENT ON COLUMN templates.captions IS '언어별 자막 데이터 (JSONB 형식)';
COMMENT ON COLUMN templates.cii_score IS '채널 영향력 지수 (0-100)';
COMMENT ON COLUMN templates.channel_info IS '채널 정보 (구독자 수, 조회수 등)';
```

**youtube_metadata JSONB 구조**:
```json
{
  "videoId": "dQw4w9WgXcQ",
  "title": "Sample Video Title",
  "description": "Video description...",
  "channelId": "UC_x5XG1OV2P6uZZ5FSM9Ttw",
  "channelTitle": "Channel Name",
  "publishedAt": "2025-01-01T00:00:00Z",
  "thumbnails": {
    "default": "https://i.ytimg.com/vi/dQw4w9WgXcQ/default.jpg",
    "medium": "https://i.ytimg.com/vi/dQw4w9WgXcQ/mqdefault.jpg",
    "high": "https://i.ytimg.com/vi/dQw4w9WgXcQ/hqdefault.jpg",
    "standard": "https://i.ytimg.com/vi/dQw4w9WgXcQ/sddefault.jpg",
    "maxres": "https://i.ytimg.com/vi/dQw4w9WgXcQ/maxresdefault.jpg"
  },
  "duration": "PT3M33S",
  "videoType": "long-form",
  "tags": ["music", "pop", "80s"],
  "categoryId": "10",
  "viewCount": 1000000,
  "likeCount": 50000,
  "commentCount": 10000
}
```

**captions JSONB 구조**:
```json
{
  "ko": {
    "language": "ko",
    "languageName": "한국어",
    "isAutoGenerated": false,
    "captions": [
      {"text": "안녕하세요", "start": 0.0, "duration": 2.5},
      {"text": "오늘은 YouTube 검색에 대해 알아보겠습니다", "start": 2.5, "duration": 3.5}
    ],
    "fullText": "안녕하세요 오늘은 YouTube 검색에 대해 알아보겠습니다"
  },
  "en": {
    "language": "en",
    "languageName": "English",
    "isAutoGenerated": true,
    "captions": [
      {"text": "Hello", "start": 0.0, "duration": 1.0},
      {"text": "Today we'll learn about YouTube search", "start": 1.0, "duration": 3.0}
    ],
    "fullText": "Hello Today we'll learn about YouTube search"
  }
}
```

**channel_info JSONB 구조**:
```json
{
  "channelId": "UC_x5XG1OV2P6uZZ5FSM9Ttw",
  "channelTitle": "Channel Name",
  "subscriberCount": 1000000,
  "viewCount": 50000000,
  "videoCount": 200,
  "customUrl": "@channelname",
  "description": "Channel description...",
  "publishedAt": "2015-01-01T00:00:00Z"
}
```

### 1.2 search_histories 테이블 (신규)

사용자별 검색 히스토리를 저장하는 테이블:

```sql
-- Migration: xxx_create_search_histories.sql
CREATE TABLE search_histories (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  keyword VARCHAR(200) NOT NULL,
  search_params JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

  -- 복합 인덱스: 사용자별 최근 검색어 조회 최적화
  CONSTRAINT unique_user_keyword UNIQUE (user_id, keyword)
);

-- 인덱스
CREATE INDEX idx_search_histories_user_id ON search_histories(user_id);
CREATE INDEX idx_search_histories_created_at ON search_histories(created_at DESC);

-- Row Level Security (Supabase)
ALTER TABLE search_histories ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own search history"
  ON search_histories FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own search history"
  ON search_histories FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own search history"
  ON search_histories FOR DELETE
  USING (auth.uid() = user_id);

-- 자동 정리 함수 (최근 10개만 유지)
CREATE OR REPLACE FUNCTION cleanup_old_search_histories()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM search_histories
  WHERE user_id = NEW.user_id
  AND id NOT IN (
    SELECT id FROM search_histories
    WHERE user_id = NEW.user_id
    ORDER BY created_at DESC
    LIMIT 10
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_cleanup_search_histories
AFTER INSERT ON search_histories
FOR EACH ROW
EXECUTE FUNCTION cleanup_old_search_histories();

-- 코멘트
COMMENT ON TABLE search_histories IS '사용자별 YouTube 검색 히스토리 (최근 10개 유지)';
COMMENT ON COLUMN search_histories.search_params IS '검색 시 사용한 필터 파라미터 (JSONB)';
```

**search_params JSONB 예시**:
```json
{
  "videoType": "shorts",
  "regionCode": "KR",
  "publishedAfter": "2025-01-01T00:00:00Z",
  "order": "viewCount",
  "minViewCount": 100000,
  "minCiiScore": 70
}
```

---

## 2. Backend Data Models (Pydantic)

### 2.1 YouTube Search 관련 스키마

```python
# backend/src/api/v1/schemas/youtube.py
from pydantic import BaseModel, Field, validator
from typing import Optional, Literal
from datetime import datetime
from enum import Enum

# Enums
class VideoType(str, Enum):
    SHORTS = "shorts"
    LONG_FORM = "long-form"
    ALL = "all"

class OrderType(str, Enum):
    RELEVANCE = "relevance"
    VIEW_COUNT = "viewCount"
    DATE = "date"
    RATING = "rating"
    CII = "cii"

# Request Schemas
class SearchQuery(BaseModel):
    """YouTube 영상 검색 쿼리 파라미터"""
    keyword: str = Field(..., min_length=1, max_length=200, description="검색 키워드")
    videoType: VideoType = Field(default=VideoType.ALL, description="영상 타입 필터")
    publishedAfter: Optional[datetime] = Field(None, description="업로드 기간 시작")
    publishedBefore: Optional[datetime] = Field(None, description="업로드 기간 종료")
    regionCode: str = Field(default="KR", description="국가 코드 (KR, JP, US 등)")
    order: OrderType = Field(default=OrderType.RELEVANCE, description="정렬 기준")
    channelId: Optional[str] = Field(None, description="특정 채널 필터")
    maxResults: int = Field(default=25, ge=1, le=50, description="영상 수집 수")
    pageToken: Optional[str] = Field(None, description="페이지네이션 토큰")
    minViewCount: Optional[int] = Field(None, ge=0, description="최소 조회수")
    minSubscribers: Optional[int] = Field(None, ge=0, description="최소 구독자 수")
    minCiiScore: Optional[float] = Field(None, ge=0, le=100, description="최소 CII 점수")
    maxCiiScore: Optional[float] = Field(None, ge=0, le=100, description="최대 CII 점수")

    @validator('keyword')
    def sanitize_keyword(cls, v):
        import re
        # XSS 방지: HTML 태그 제거
        sanitized = re.sub(r'<[^>]+>', '', v)
        return sanitized.strip()

    @validator('maxCiiScore')
    def validate_cii_range(cls, v, values):
        if v is not None and values.get('minCiiScore') is not None:
            if v < values['minCiiScore']:
                raise ValueError('maxCiiScore must be greater than minCiiScore')
        return v


class SaveYouTubeTemplateRequest(BaseModel):
    """YouTube 영상을 템플릿으로 저장하는 요청"""
    videoId: str = Field(..., min_length=11, max_length=11, description="YouTube 영상 ID")
    name: str = Field(..., min_length=1, max_length=100, description="템플릿 이름")
    category: str = Field(..., description="템플릿 카테고리")
    includeCaptions: bool = Field(default=False, description="자막 포함 여부")
    captionLanguages: Optional[list[str]] = Field(None, description="포함할 자막 언어 코드 목록")

    @validator('videoId')
    def validate_video_id(cls, v):
        import re
        # YouTube 영상 ID 형식 검증
        if not re.match(r'^[a-zA-Z0-9_-]{11}$', v):
            raise ValueError('Invalid YouTube video ID format')
        return v


# Response Schemas
class ThumbnailSet(BaseModel):
    """썸네일 URL 세트"""
    default: str
    medium: str
    high: str
    standard: Optional[str] = None
    maxres: Optional[str] = None


class YouTubeSearchResult(BaseModel):
    """YouTube 영상 검색 결과 항목"""
    videoId: str
    title: str
    description: str
    thumbnails: ThumbnailSet
    channelId: str
    channelTitle: str
    channelSubscriberCount: Optional[int] = None
    publishedAt: datetime
    viewCount: int
    likeCount: Optional[int] = None
    duration: str  # ISO 8601 format (e.g., PT1M30S)
    videoType: Literal["shorts", "long-form"]
    tags: Optional[list[str]] = None
    categoryId: Optional[str] = None
    captionsAvailable: bool = False
    availableCaptions: Optional[list[str]] = None
    ciiScore: Optional[float] = None

    class Config:
        json_schema_extra = {
            "example": {
                "videoId": "dQw4w9WgXcQ",
                "title": "Sample Video Title",
                "description": "This is a sample video description",
                "thumbnails": {
                    "default": "https://i.ytimg.com/vi/dQw4w9WgXcQ/default.jpg",
                    "medium": "https://i.ytimg.com/vi/dQw4w9WgXcQ/mqdefault.jpg",
                    "high": "https://i.ytimg.com/vi/dQw4w9WgXcQ/hqdefault.jpg"
                },
                "channelId": "UC_x5XG1OV2P6uZZ5FSM9Ttw",
                "channelTitle": "Sample Channel",
                "channelSubscriberCount": 1000000,
                "publishedAt": "2025-01-01T00:00:00Z",
                "viewCount": 1000000,
                "likeCount": 50000,
                "duration": "PT3M33S",
                "videoType": "long-form",
                "tags": ["music", "pop"],
                "categoryId": "10",
                "captionsAvailable": True,
                "availableCaptions": ["ko", "en"],
                "ciiScore": 75.5
            }
        }


class SearchResponse(BaseModel):
    """검색 결과 응답"""
    items: list[YouTubeSearchResult]
    nextPageToken: Optional[str] = None
    prevPageToken: Optional[str] = None
    totalResults: int
    resultsPerPage: int


class CaptionTrack(BaseModel):
    """사용 가능한 자막 트랙 정보"""
    language: str = Field(..., description="언어 코드 (ko, en, ja 등)")
    languageName: str = Field(..., description="언어 이름 (한국어, English)")
    isAutoGenerated: bool = Field(..., description="자동 생성 자막 여부")
    captionId: str = Field(..., description="YouTube 자막 ID")


class Caption(BaseModel):
    """개별 자막 항목"""
    text: str = Field(..., description="자막 텍스트")
    start: float = Field(..., ge=0, description="시작 시간 (초)")
    duration: float = Field(..., ge=0, description="지속 시간 (초)")


class CaptionData(BaseModel):
    """특정 언어의 자막 데이터"""
    videoId: str
    language: str
    languageName: str
    isAutoGenerated: bool
    captions: list[Caption]
    fullText: str  # 타임스탬프 제거한 전체 텍스트


class CIIMetrics(BaseModel):
    """채널 영향력 지수 (CII) 계산 데이터"""
    channelId: str
    channelTitle: str
    subscriberCount: int = Field(..., ge=0, description="구독자 수")
    averageViewCount: float = Field(..., ge=0, description="평균 조회수 (최근 10개 영상)")
    uploadFrequency: float = Field(..., ge=0, description="영상 게시 빈도 (월평균)")
    averageLikeRatio: float = Field(..., ge=0, le=1, description="평균 좋아요 비율 (0-1)")
    ciiScore: float = Field(..., ge=0, le=100, description="최종 CII 점수 (0-100)")

    class Config:
        json_schema_extra = {
            "example": {
                "channelId": "UC_x5XG1OV2P6uZZ5FSM9Ttw",
                "channelTitle": "Sample Channel",
                "subscriberCount": 1000000,
                "averageViewCount": 500000.0,
                "uploadFrequency": 8.5,
                "averageLikeRatio": 0.035,
                "ciiScore": 75.5
            }
        }


class SearchHistoryItem(BaseModel):
    """검색 히스토리 항목"""
    id: str
    keyword: str
    searchParams: Optional[dict] = None
    createdAt: datetime


class SearchHistoryCreateRequest(BaseModel):
    """검색 히스토리 생성 요청"""
    keyword: str = Field(..., min_length=1, max_length=200)
    searchParams: Optional[dict] = None
```

---

## 3. Frontend Types (TypeScript)

### 3.1 YouTube API Types

```typescript
// frontend/src/lib/api/youtube.ts

/**
 * 영상 타입
 */
export type VideoType = 'shorts' | 'long-form' | 'all';

/**
 * 정렬 기준
 */
export type OrderType = 'relevance' | 'viewCount' | 'date' | 'rating' | 'cii';

/**
 * 썸네일 세트
 */
export interface ThumbnailSet {
  default: string;
  medium: string;
  high: string;
  standard?: string;
  maxres?: string;
}

/**
 * YouTube 검색 쿼리 파라미터
 */
export interface SearchQuery {
  keyword: string;
  videoType?: VideoType;
  publishedAfter?: Date;
  publishedBefore?: Date;
  regionCode?: string;
  order?: OrderType;
  channelId?: string;
  maxResults?: number;
  pageToken?: string;
  minViewCount?: number;
  minSubscribers?: number;
  minCiiScore?: number;
  maxCiiScore?: number;
}

/**
 * YouTube 영상 검색 결과
 */
export interface YouTubeSearchResult {
  videoId: string;
  title: string;
  description: string;
  thumbnails: ThumbnailSet;
  channelId: string;
  channelTitle: string;
  channelSubscriberCount?: number;
  publishedAt: string;
  viewCount: number;
  likeCount?: number;
  duration: string;
  videoType: 'shorts' | 'long-form';
  tags?: string[];
  categoryId?: string;
  captionsAvailable: boolean;
  availableCaptions?: string[];
  ciiScore?: number;
}

/**
 * 검색 결과 응답
 */
export interface SearchResponse {
  items: YouTubeSearchResult[];
  nextPageToken?: string;
  prevPageToken?: string;
  totalResults: number;
  resultsPerPage: number;
}

/**
 * 자막 트랙 정보
 */
export interface CaptionTrack {
  language: string;
  languageName: string;
  isAutoGenerated: boolean;
  captionId: string;
}

/**
 * 개별 자막 항목
 */
export interface Caption {
  text: string;
  start: number;
  duration: number;
}

/**
 * 자막 데이터
 */
export interface CaptionData {
  videoId: string;
  language: string;
  languageName: string;
  isAutoGenerated: boolean;
  captions: Caption[];
  fullText: string;
}

/**
 * CII (Channel Influence Index) 메트릭
 */
export interface CIIMetrics {
  channelId: string;
  channelTitle: string;
  subscriberCount: number;
  averageViewCount: number;
  uploadFrequency: number;
  averageLikeRatio: number;
  ciiScore: number;
}

/**
 * 템플릿 저장 요청
 */
export interface SaveYouTubeTemplateRequest {
  videoId: string;
  name: string;
  category: string;
  includeCaptions?: boolean;
  captionLanguages?: string[];
}

/**
 * 검색 히스토리 항목
 */
export interface SearchHistoryItem {
  id: string;
  keyword: string;
  searchParams?: Partial<SearchQuery>;
  createdAt: string;
}

/**
 * 검색 히스토리 생성 요청
 */
export interface SearchHistoryCreateRequest {
  keyword: string;
  searchParams?: Partial<SearchQuery>;
}
```

### 3.2 Form State Types

```typescript
// frontend/src/components/features/youtube/types.ts

/**
 * 검색 필터 상태
 */
export interface SearchFilters {
  videoType: VideoType;
  uploadPeriod?: {
    start?: Date;
    end?: Date;
  };
  regionCode: string;
  order: OrderType;
  minViewCount?: number;
  minSubscribers?: number;
  ciiRange?: {
    min?: number;
    max?: number;
  };
}

/**
 * 영상 상세 모달 상태
 */
export interface VideoDetailModalState {
  isOpen: boolean;
  video: YouTubeSearchResult | null;
  selectedCaptionLanguages: string[];
}

/**
 * 템플릿 저장 폼 상태
 */
export interface SaveTemplateFormState {
  name: string;
  category: string;
  includeCaptions: boolean;
  selectedLanguages: string[];
}
```

---

## 4. Redis Cache Keys

### 4.1 캐시 키 네이밍 컨벤션

```
youtube:{resource}:{identifier}[:{subkey}]

Examples:
- youtube:search:a3f2d8e1c4b6  (검색 파라미터 해시)
- youtube:video:dQw4w9WgXcQ
- youtube:caption:dQw4w9WgXcQ:ko
- youtube:cii:UC_x5XG1OV2P6uZZ5FSM9Ttw
- youtube:quota:2025-01-15
```

### 4.2 캐시 데이터 구조

```python
# backend/src/core/cache.py
from typing import TypedDict, Optional

class CacheConfig(TypedDict):
    """캐시 설정"""
    ttl: int  # Time to live (seconds)
    key_prefix: str

# 리소스별 캐시 TTL 설정
CACHE_CONFIGS: dict[str, CacheConfig] = {
    "search": {"ttl": 900, "key_prefix": "youtube:search"},  # 15분
    "video": {"ttl": 3600, "key_prefix": "youtube:video"},  # 1시간
    "caption": {"ttl": 86400, "key_prefix": "youtube:caption"},  # 24시간
    "cii": {"ttl": 21600, "key_prefix": "youtube:cii"},  # 6시간
    "quota": {"ttl": 86400, "key_prefix": "youtube:quota"},  # 24시간
}
```

---

## 5. Error Types

### 5.1 Backend Custom Exceptions

```python
# backend/src/core/youtube/exceptions.py

class YouTubeAPIError(Exception):
    """YouTube API 호출 실패"""
    def __init__(self, message: str, status_code: int, error_code: str):
        self.message = message
        self.status_code = status_code
        self.error_code = error_code
        super().__init__(self.message)


class QuotaExceededError(YouTubeAPIError):
    """일일 API quota 초과"""
    def __init__(self):
        super().__init__(
            message="일일 검색 한도를 초과했습니다. 내일 다시 시도해주세요.",
            status_code=403,
            error_code="QUOTA_EXCEEDED"
        )


class InvalidVideoIdError(YouTubeAPIError):
    """잘못된 영상 ID"""
    def __init__(self, video_id: str):
        super().__init__(
            message=f"영상을 찾을 수 없습니다: {video_id}",
            status_code=404,
            error_code="VIDEO_NOT_FOUND"
        )


class CaptionNotAvailableError(YouTubeAPIError):
    """자막을 사용할 수 없음"""
    def __init__(self, video_id: str, language: str):
        super().__init__(
            message=f"해당 언어의 자막을 찾을 수 없습니다: {language}",
            status_code=404,
            error_code="CAPTION_NOT_FOUND"
        )


class RateLimitError(YouTubeAPIError):
    """Rate limit 초과"""
    def __init__(self, retry_after: int):
        super().__init__(
            message=f"{retry_after}초 후 다시 시도해주세요.",
            status_code=429,
            error_code="RATE_LIMIT_EXCEEDED"
        )
```

### 5.2 Frontend Error Types

```typescript
// frontend/src/lib/errors/youtube.ts

export class YouTubeError extends Error {
  constructor(
    message: string,
    public statusCode: number,
    public errorCode: string
  ) {
    super(message);
    this.name = 'YouTubeError';
  }
}

export class QuotaExceededError extends YouTubeError {
  constructor() {
    super('일일 검색 한도를 초과했습니다. 내일 다시 시도해주세요.', 403, 'QUOTA_EXCEEDED');
    this.name = 'QuotaExceededError';
  }
}

export class VideoNotFoundError extends YouTubeError {
  constructor(videoId: string) {
    super(`영상을 찾을 수 없습니다: ${videoId}`, 404, 'VIDEO_NOT_FOUND');
    this.name = 'VideoNotFoundError';
  }
}

export class CaptionNotAvailableError extends YouTubeError {
  constructor(language: string) {
    super(`해당 언어의 자막을 찾을 수 없습니다: ${language}`, 404, 'CAPTION_NOT_FOUND');
    this.name = 'CaptionNotAvailableError';
  }
}

export class RateLimitError extends YouTubeError {
  constructor(public retryAfter: number) {
    super(`${retryAfter}초 후 다시 시도해주세요.`, 429, 'RATE_LIMIT_EXCEEDED');
    this.name = 'RateLimitError';
  }
}
```

---

## 6. Validation Rules

### 6.1 입력 검증 규칙

| 필드 | 타입 | 제약조건 |
|------|------|----------|
| keyword | string | 1-200자, HTML 태그 제거 |
| videoId | string | 정확히 11자, 영문/숫자/-/_ 만 허용 |
| maxResults | int | 1-50 범위 |
| minViewCount | int | 0 이상 |
| minSubscribers | int | 0 이상 |
| minCiiScore | float | 0-100 범위 |
| maxCiiScore | float | 0-100 범위, minCiiScore보다 크거나 같아야 함 |
| regionCode | string | ISO 3166-1 alpha-2 (2자 국가 코드) |
| language | string | ISO 639-1 (2자 언어 코드) |

### 6.2 비즈니스 로직 검증

```python
# backend/src/core/youtube/validators.py

def validate_duration_for_shorts(duration: str) -> bool:
    """
    Shorts 분류 검증: 60초 이하
    """
    from .utils import parse_duration
    return parse_duration(duration) <= 60


def validate_cii_score(score: float) -> bool:
    """
    CII 점수 범위 검증: 0-100
    """
    return 0 <= score <= 100


def validate_search_params(params: SearchQuery) -> None:
    """
    검색 파라미터 전체 검증
    """
    if params.minCiiScore and params.maxCiiScore:
        if params.minCiiScore > params.maxCiiScore:
            raise ValueError("minCiiScore must be less than or equal to maxCiiScore")

    if params.publishedAfter and params.publishedBefore:
        if params.publishedAfter > params.publishedBefore:
            raise ValueError("publishedAfter must be before publishedBefore")
```

---

## 7. Constants

### 7.1 Backend Constants

```python
# backend/src/core/youtube/constants.py

# YouTube API Quota Costs
QUOTA_COSTS = {
    "search.list": 100,
    "videos.list": 1,
    "channels.list": 1,
    "captions.list": 50,
    "captions.download": 200,
}

# Daily quota limit
DAILY_QUOTA_LIMIT = 10_000

# Cache TTL (seconds)
CACHE_TTL = {
    "search": 15 * 60,  # 15 minutes
    "video": 60 * 60,  # 1 hour
    "caption": 24 * 60 * 60,  # 24 hours
    "cii": 6 * 60 * 60,  # 6 hours
}

# Video type classification
SHORTS_MAX_DURATION = 60  # seconds

# CII calculation weights
CII_WEIGHTS = {
    "subscribers": 0.40,
    "avg_views": 0.30,
    "upload_frequency": 0.15,
    "like_ratio": 0.15,
}

# CII normalization references
CII_REFERENCES = {
    "subscribers": 10_000_000,  # 1천만 구독자
    "avg_views": 1_000_000,  # 100만 조회수
    "upload_frequency": 10.0,  # 월 10개 영상
    "like_ratio": 0.05,  # 5% 좋아요 비율
}

# Supported region codes (ISO 3166-1 alpha-2)
SUPPORTED_REGIONS = [
    "KR",  # 한국
    "JP",  # 일본
    "US",  # 미국
    "GB",  # 영국
    "DE",  # 독일
    "FR",  # 프랑스
    "CN",  # 중국
]

# Supported caption languages (ISO 639-1)
SUPPORTED_CAPTION_LANGUAGES = [
    "ko",  # 한국어
    "en",  # English
    "ja",  # 日本語
    "zh",  # 中文
    "es",  # Español
    "fr",  # Français
    "de",  # Deutsch
]
```

### 7.2 Frontend Constants

```typescript
// frontend/src/lib/constants/youtube.ts

/**
 * 업로드 기간 프리셋
 */
export const UPLOAD_PERIOD_PRESETS = [
  { label: '1시간 이내', hours: 1 },
  { label: '오늘', hours: 24 },
  { label: '이번주', days: 7 },
  { label: '이번달', days: 30 },
  { label: '올해', days: 365 },
] as const;

/**
 * 지원 국가 목록
 */
export const SUPPORTED_REGIONS = [
  { code: 'KR', name: '한국' },
  { code: 'JP', name: '일본' },
  { code: 'US', name: '미국' },
  { code: 'GB', name: '영국' },
  { code: 'DE', name: '독일' },
  { code: 'FR', name: '프랑스' },
  { code: 'CN', name: '중국' },
] as const;

/**
 * 지원 자막 언어
 */
export const SUPPORTED_CAPTION_LANGUAGES = [
  { code: 'ko', name: '한국어' },
  { code: 'en', name: 'English' },
  { code: 'ja', name: '日本語' },
  { code: 'zh', name: '中文' },
  { code: 'es', name: 'Español' },
  { code: 'fr', name: 'Français' },
  { code: 'de', name: 'Deutsch' },
] as const;

/**
 * 영상 수집 수 옵션
 */
export const COLLECTION_COUNT_OPTIONS = [
  { value: 10, label: '10개' },
  { value: 25, label: '25개' },
  { value: 50, label: '50개' },
] as const;

/**
 * Shorts 최대 길이 (초)
 */
export const SHORTS_MAX_DURATION = 60;
```

---

## 8. 데이터 흐름 다이어그램

```
[사용자] → [Frontend]
              ↓ SearchQuery
          [API Client]
              ↓ HTTP Request
          [Backend API]
              ↓
          [Rate Limiter] → Redis (사용량 체크)
              ↓
          [Cache Layer] → Redis (캐시 조회)
              ↓ (Cache Miss)
          [YouTube Service]
              ↓ YouTube Data API v3
          [YouTube API]
              ↓ Response
          [Data Transformation]
              ↓
          [Cache Write] → Redis (캐시 저장)
              ↓
          [Quota Tracking] → Redis (사용량 기록)
              ↓ YouTubeSearchResult[]
          [Frontend]
              ↓
          [VideoGrid 표시]
```

---

## 결론

이 데이터 모델 문서는 다음을 정의합니다:

1. **DB 스키마**: `templates` 확장, `search_histories` 신규 테이블
2. **Backend 타입**: Pydantic 스키마 (요청/응답 모델)
3. **Frontend 타입**: TypeScript 인터페이스
4. **캐시 구조**: Redis 캐시 키 및 TTL 설정
5. **에러 타입**: 커스텀 예외 및 에러 핸들링
6. **검증 규칙**: 입력 검증 및 비즈니스 로직 제약
7. **상수 정의**: 공통 상수 및 설정값

다음 단계: API 계약(OpenAPI) 문서 작성
