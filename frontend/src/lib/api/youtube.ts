/**
 * YouTube API 클라이언트 타입 정의
 *
 * YouTube Data API v3 응답 타입과 클라이언트 함수를 정의합니다.
 */

import { apiClient } from './client';
import type { AxiosRequestHeaders } from 'axios';

// ============================================================================
// YouTube API 응답 타입
// ============================================================================

/**
 * YouTube 영상 기본 정보
 */
export interface YouTubeVideo {
  id: string;
  title: string;
  description: string;
  thumbnailUrl: string;
  channelId: string;
  channelTitle: string;
  subscriberCount?: number;
  channelTotalVideos?: number;
  publishedAt: string;
  duration: number; // 초 단위
  viewCount: number;
  likeCount: number;
  commentCount: number;
  tags?: string[];
  categoryId?: string;
  performanceRatio?: number; // 성과도 배율 (백엔드 제공 시)
  channelContribution?: number; // 채널 기여도 (백엔드 제공 시)
  cii?: number; // Channel Influence Index (백엔드 제공 시)
  isShorts: boolean; // 60초 이하 여부
}

/**
 * YouTube 채널 정보
 */
export interface YouTubeChannel {
  id: string;
  title: string;
  description: string;
  thumbnailUrl: string;
  subscriberCount: number;
  videoCount: number;
  viewCount: number;
  customUrl?: string;
}

/**
 * 검색 필터 옵션
 */
export interface YouTubeSearchFilters {
  videoType?: 'shorts' | 'long' | 'all'; // 쇼츠/롱폼/전체
  publishedAfter?: string; // ISO 8601 format
  publishedBefore?: string; // ISO 8601 format
  regionCode?: string; // KR, JP, US 등
  minViewCount?: number;
  maxViewCount?: number;
  minSubscribers?: number;
  maxSubscribers?: number;
  minCiiScore?: number; // Channel Influence Index
  maxCiiScore?: number;
  order?: 'relevance' | 'date' | 'viewCount' | 'rating' | 'cii';
}

/**
 * 검색 요청 파라미터
 */
export interface YouTubeSearchParams {
  query: string;
  maxResults?: number; // 25~50
  filters?: YouTubeSearchFilters;
  pageToken?: string; // 페이지네이션용
}

/**
 * 검색 결과
 */
export interface YouTubeSearchResult {
  videos: YouTubeVideo[];
  nextPageToken?: string;
  totalResults: number;
}

type RawYouTubeVideo = {
  video_id?: string;
  videoId?: string;
  id?: string;
  title: string;
  description: string;
  thumbnail_url?: string;
  thumbnailUrl?: string;
  channel_id?: string;
  channelId?: string;
  channel_title?: string;
  channelTitle?: string;
  published_at?: string;
  publishedAt?: string;
  duration: number;
  view_count?: number;
  viewCount?: number;
  like_count?: number;
  likeCount?: number;
  comment_count?: number;
  commentCount?: number;
  tags?: string[];
  category_id?: string;
  categoryId?: string;
  subscriber_count?: number;
  subscriberCount?: number;
  channel_total_videos?: number;
  channelTotalVideos?: number;
  performance_ratio?: number;
  performanceRatio?: number;
  channel_contribution?: number;
  channelContribution?: number;
  cii?: number;
};

function mapVideo(raw: RawYouTubeVideo): YouTubeVideo {
  const durationSeconds = raw.duration ?? 0;

  return {
    id: raw.id ?? raw.videoId ?? raw.video_id ?? "",
    title: raw.title,
    description: raw.description,
    thumbnailUrl: raw.thumbnailUrl ?? raw.thumbnail_url ?? "",
    channelId: raw.channelId ?? raw.channel_id ?? "",
    channelTitle: raw.channelTitle ?? raw.channel_title ?? "",
    subscriberCount: raw.subscriberCount ?? raw.subscriber_count,
    channelTotalVideos: raw.channelTotalVideos ?? raw.channel_total_videos,
    publishedAt: raw.publishedAt ?? raw.published_at ?? "",
    duration: durationSeconds,
    viewCount: raw.viewCount ?? raw.view_count ?? 0,
    likeCount: raw.likeCount ?? raw.like_count ?? 0,
    commentCount: raw.commentCount ?? raw.comment_count ?? 0,
    tags: raw.tags ?? [],
    categoryId: raw.categoryId ?? raw.category_id,
    performanceRatio:
      raw.performanceRatio ?? raw.performance_ratio ?? undefined,
    channelContribution:
      raw.channelContribution ?? raw.channel_contribution ?? undefined,
    cii: raw.cii ?? undefined,
    isShorts: durationSeconds <= 60,
  };
}

function buildYouTubeHeaders(apiKey?: string): AxiosRequestHeaders | undefined {
  return apiKey
    ? {
        "X-YouTube-API-Key": apiKey,
      }
    : undefined;
}

/**
 * 자막 트랙 정보
 */
export interface CaptionTrack {
  language: string;
  languageCode: string;
  name: string;
  isAutoGenerated: boolean;
}

/**
 * 자막 데이터
 */
export interface CaptionData {
  language: string;
  captions: CaptionSegment[];
}

/**
 * 자막 세그먼트
 */
export interface CaptionSegment {
  start: number; // 시작 시간 (초)
  duration: number; // 지속 시간 (초)
  text: string;
}

/**
 * CII (Channel Influence Index) 점수
 */
export interface CIIMetrics {
  channelId: string;
  score: number; // 0-100
  subscriberScore: number;
  viewCountScore: number;
  uploadFrequencyScore: number;
  engagementScore: number;
  calculatedAt: string;
}

// ============================================================================
// API 클라이언트 함수
// ============================================================================

/**
 * YouTube 영상 검색
 */
export async function searchVideos(
  params: YouTubeSearchParams,
  apiKey?: string
): Promise<YouTubeSearchResult> {
  const filters = params.filters || {};

  // 백엔드 API 파라미터로 변환
  const apiParams: Record<string, any> = {
    query: params.query,
    max_results: params.maxResults || 25,
  };

  if (params.pageToken) {
    apiParams.page_token = params.pageToken;
  }

  if (filters.regionCode) {
    apiParams.region_code = filters.regionCode;
  }

  if (filters.publishedAfter) {
    apiParams.published_after = filters.publishedAfter;
  }

  if (filters.publishedBefore) {
    apiParams.published_before = filters.publishedBefore;
  }

  if (filters.videoType && filters.videoType !== 'all') {
    // videoType을 YouTube API의 videoDuration으로 변환
    apiParams.video_duration = filters.videoType === 'shorts' ? 'short' : filters.videoType;
  }

  if (filters.order) {
    apiParams.order = filters.order;
  }

  if (filters.minViewCount !== undefined && filters.minViewCount > 0) {
    apiParams.min_view_count = filters.minViewCount;
  }

  if (filters.minSubscribers !== undefined && filters.minSubscribers > 0) {
    apiParams.min_subscriber_count = filters.minSubscribers;
  }

  const response = await apiClient.get('/api/v1/youtube/search', {
    params: apiParams,
    headers: buildYouTubeHeaders(apiKey),
  });
  const data = response.data as any;
  const rawVideos: RawYouTubeVideo[] = data.videos ?? data.results ?? [];

  return {
    videos: rawVideos.map(mapVideo),
    nextPageToken: data.nextPageToken ?? data.next_page_token,
    totalResults: data.totalResults ?? data.total_results ?? rawVideos.length,
  };
}

/**
 * 영상 상세 정보 조회
 */
export async function getVideoDetails(
  videoId: string,
  apiKey?: string
): Promise<YouTubeVideo> {
  const response = await apiClient.get(`/api/v1/youtube/videos/${videoId}`, {
    headers: buildYouTubeHeaders(apiKey),
  });
  return mapVideo(response.data as RawYouTubeVideo);
}

/**
 * 영상 자막 목록 조회
 */
export async function getCaptionTracks(
  videoId: string
): Promise<CaptionTrack[]> {
  const response = await apiClient.get(
    `/api/v1/youtube/videos/${videoId}/captions`
  );
  return response.data;
}

/**
 * 특정 언어 자막 다운로드
 */
export async function downloadCaption(
  videoId: string,
  language: string
): Promise<CaptionData> {
  const response = await apiClient.get(
    `/api/v1/youtube/videos/${videoId}/captions/${language}`
  );
  return response.data;
}

/**
 * 채널 CII 점수 조회
 */
export async function getChannelCII(channelId: string): Promise<CIIMetrics> {
  const response = await apiClient.get(
    `/api/v1/youtube/channels/${channelId}/cii`
  );
  return response.data;
}

/**
 * 검색 히스토리 조회
 */
export async function getSearchHistory(): Promise<string[]> {
  const response = await apiClient.get('/api/v1/youtube/search-history');
  return response.data;
}

/**
 * 검색 히스토리 저장
 */
export async function saveSearchHistory(keyword: string): Promise<void> {
  await apiClient.post('/api/v1/youtube/search-history', { keyword });
}

/**
 * 검색 히스토리 삭제
 */
export async function deleteSearchHistory(keyword: string): Promise<void> {
  await apiClient.delete(`/api/v1/youtube/search-history/${keyword}`);
}
