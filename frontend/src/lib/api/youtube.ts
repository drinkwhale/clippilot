/**
 * YouTube API 클라이언트 타입 정의
 *
 * YouTube Data API v3 응답 타입과 클라이언트 함수를 정의합니다.
 */

import { apiClient } from './client';
import type { AxiosRequestHeaders } from 'axios';

// ============================================================================
// YouTube API 응답 타입
// ============================================================================

/**
 * YouTube 영상 기본 정보
 */
export interface YouTubeVideo {
  id: string;
  title: string;
  description: string;
  thumbnailUrl: string;
  channelId: string;
  channelTitle: string;
  subscriberCount?: number;
  channelTotalVideos?: number;
  publishedAt: string;
  duration: number; // 초 단위
  viewCount: number;
  likeCount: number;
  commentCount: number;
  tags?: string[];
  categoryId?: string;
  performanceRatio?: number; // 성과도 배율 (백엔드 제공 시)
  channelContribution?: number; // 채널 기여도 (백엔드 제공 시)
  cii?: number; // Channel Influence Index (백엔드 제공 시)
  isShorts: boolean; // 60초 이하 여부
}

/**
 * YouTube 채널 정보
 */
export interface YouTubeChannel {
  id: string;
  title: string;
  description: string;
  thumbnailUrl: string;
  subscriberCount: number;
  videoCount: number;
  viewCount: number;
  customUrl?: string;
}

/**
 * 검색 필터 옵션
 */
export interface YouTubeSearchFilters {
  videoType?: 'shorts' | 'long' | 'all'; // 쇼츠/롱폼/전체
  publishedAfter?: string; // ISO 8601 format
  publishedBefore?: string; // ISO 8601 format
  regionCode?: string; // KR, JP, US 등
  minViewCount?: number;
  maxViewCount?: number;
  minSubscribers?: number;
  maxSubscribers?: number;
  minCiiScore?: number; // Channel Influence Index
  maxCiiScore?: number;
  order?: 'relevance' | 'date' | 'viewCount' | 'rating' | 'cii';
}

/**
 * 검색 요청 파라미터
 */
export interface YouTubeSearchParams {
  query: string;
  maxResults?: number; // 25~50
  filters?: YouTubeSearchFilters;
  pageToken?: string; // 페이지네이션용
}

/**
 * 검색 결과
 */
export interface YouTubeSearchResult {
  videos: YouTubeVideo[];
  nextPageToken?: string;
  totalResults: number;
}

type RawYouTubeVideo = {
  video_id?: string;
  videoId?: string;
  id?: string;
  title: string;
  description: string;
  thumbnail_url?: string;
  thumbnailUrl?: string;
  channel_id?: string;
  channelId?: string;
  channel_title?: string;
  channelTitle?: string;
  published_at?: string;
  publishedAt?: string;
  duration: number;
  view_count?: number;
  viewCount?: number;
  like_count?: number;
  likeCount?: number;
  comment_count?: number;
  commentCount?: number;
  tags?: string[];
  category_id?: string;
  categoryId?: string;
  subscriber_count?: number;
  subscriberCount?: number;
  channel_total_videos?: number;
  channelTotalVideos?: number;
  performance_ratio?: number;
  performanceRatio?: number;
  channel_contribution?: number;
  channelContribution?: number;
  cii?: number;
};

function mapVideo(raw: RawYouTubeVideo): YouTubeVideo {
  const durationSeconds = raw.duration ?? 0;

  return {
    id: raw.id ?? raw.videoId ?? raw.video_id ?? "",
    title: raw.title,
    description: raw.description,
    thumbnailUrl: raw.thumbnailUrl ?? raw.thumbnail_url ?? "",
    channelId: raw.channelId ?? raw.channel_id ?? "",
    channelTitle: raw.channelTitle ?? raw.channel_title ?? "",
    subscriberCount: raw.subscriberCount ?? raw.subscriber_count,
    channelTotalVideos: raw.channelTotalVideos ?? raw.channel_total_videos,
    publishedAt: raw.publishedAt ?? raw.published_at ?? "",
    duration: durationSeconds,
    viewCount: raw.viewCount ?? raw.view_count ?? 0,
    likeCount: raw.likeCount ?? raw.like_count ?? 0,
    commentCount: raw.commentCount ?? raw.comment_count ?? 0,
    tags: raw.tags ?? [],
    categoryId: raw.categoryId ?? raw.category_id,
    performanceRatio:
      raw.performanceRatio ?? raw.performance_ratio ?? undefined,
    channelContribution:
      raw.channelContribution ?? raw.channel_contribution ?? undefined,
    cii: raw.cii ?? undefined,
    isShorts: durationSeconds <= 60,
  };
}

function buildYouTubeHeaders(apiKey?: string): AxiosRequestHeaders | undefined {
  return apiKey
    ? {
        "X-YouTube-API-Key": apiKey,
      }
    : undefined;
}

/**
 * 자막 트랙 정보
 */
export interface CaptionTrack {
  language: string;
  languageCode: string;
  name: string;
  isAutoGenerated: boolean;
}

/**
 * 자막 데이터
 */
export interface CaptionData {
  language: string;
  captions: CaptionSegment[];
}

/**
 * 자막 세그먼트
 */
export interface CaptionSegment {
  start: number; // 시작 시간 (초)
  duration: number; // 지속 시간 (초)
  text: string;
}

/**
 * CII (Channel Influence Index) 점수
 */
export interface CIIMetrics {
  channelId: string;
  score: number; // 0-100
  subscriberScore: number;
  viewCountScore: number;
  uploadFrequencyScore: number;
  engagementScore: number;
  calculatedAt: string;
}

// ============================================================================
// API 클라이언트 함수
// ============================================================================

/**
 * YouTube 영상 검색
 */
export async function searchVideos(
  params: YouTubeSearchParams,
  apiKey?: string
): Promise<YouTubeSearchResult> {
  const filters = params.filters || {};

  // 백엔드 API 파라미터로 변환
  const apiParams: Record<string, any> = {
    query: params.query,
    max_results: params.maxResults || 25,
  };

  if (params.pageToken) {
    apiParams.page_token = params.pageToken;
  }

  if (filters.regionCode) {
    apiParams.region_code = filters.regionCode;
  }

  if (filters.publishedAfter) {
    apiParams.published_after = filters.publishedAfter;
  }

  if (filters.publishedBefore) {
    apiParams.published_before = filters.publishedBefore;
  }

  if (filters.videoType && filters.videoType !== 'all') {
    // videoType을 YouTube API의 videoDuration으로 변환
    apiParams.video_duration = filters.videoType === 'shorts' ? 'short' : filters.videoType;
  }

  if (filters.order) {
    apiParams.order = filters.order;
  }

  if (filters.minViewCount !== undefined && filters.minViewCount > 0) {
    apiParams.min_view_count = filters.minViewCount;
  }

  if (filters.minSubscribers !== undefined && filters.minSubscribers > 0) {
    apiParams.min_subscriber_count = filters.minSubscribers;
  }

  const response = await apiClient.get('/api/v1/youtube/search', {
    params: apiParams,
    headers: buildYouTubeHeaders(apiKey),
  });
  const data = response.data as any;
  const rawVideos: RawYouTubeVideo[] = data.videos ?? data.results ?? [];

  return {
    videos: rawVideos.map(mapVideo),
    nextPageToken: data.nextPageToken ?? data.next_page_token,
    totalResults: data.totalResults ?? data.total_results ?? rawVideos.length,
  };
}

/**
 * 영상 상세 정보 조회
 */
export async function getVideoDetails(
  videoId: string,
  apiKey?: string
): Promise<YouTubeVideo> {
  const response = await apiClient.get(`/api/v1/youtube/videos/${videoId}`, {
    headers: buildYouTubeHeaders(apiKey),
  });
  return mapVideo(response.data as RawYouTubeVideo);
}

/**
 * 자막 정보
 */
export interface Caption {
  language: string;
  languageCode: string;
  isGenerated: boolean;
}

/**
 * 댓글 정보
 */
export interface Comment {
  commentId: string;
  author: string;
  authorChannelId: string;
  text: string;
  likeCount: number;
  publishedAt: string;
  replyCount: number;
}

/**
 * 채널 상세 정보
 */
export interface ChannelDetail {
  channelId: string;
  title: string;
  description: string;
  customUrl?: string;
  publishedAt: string;
  thumbnailUrl?: string;
  subscriberCount: number;
  videoCount: number;
  viewCount: number;
  keywords?: string;
  country?: string;
}

/**
 * 영상 자막 목록 조회
 */
export async function getVideoCaptions(
  videoId: string,
  apiKey?: string
): Promise<Caption[]> {
  const response = await apiClient.get(
    `/api/v1/youtube/videos/${videoId}/captions`,
    { headers: buildYouTubeHeaders(apiKey) }
  );
  return response.data.transcripts || [];
}

/**
 * 영상 댓글 조회
 */
export async function getVideoComments(
  videoId: string,
  maxResults: number = 20,
  apiKey?: string
): Promise<Comment[]> {
  const response = await apiClient.get(
    `/api/v1/youtube/videos/${videoId}/comments`,
    {
      params: { max_results: maxResults },
      headers: buildYouTubeHeaders(apiKey),
    }
  );
  return response.data.comments || [];
}

/**
 * 채널 상세 정보 조회
 */
export async function getChannelDetails(
  channelId: string,
  apiKey?: string
): Promise<ChannelDetail> {
  const response = await apiClient.get(
    `/api/v1/youtube/channels/${channelId}`,
    { headers: buildYouTubeHeaders(apiKey) }
  );
  return response.data;
}

/**
 * 자막 세그먼트 정보
 */
export interface TranscriptSegment {
  text: string;
  start: number;
  duration: number;
}

/**
 * 자막 응답 정보
 */
export interface TranscriptResponse {
  videoId: string;
  language: string;
  segments: TranscriptSegment[];
  fullText: string;
}

/**
 * 사용 가능한 자막 정보
 */
export interface AvailableTranscript {
  language: string;
  languageCode: string;
  isGenerated: boolean;
}

/**
 * YouTube 영상 자막 다운로드
 */
export async function getVideoTranscript(
  videoId: string,
  languages?: string[],
  apiKey?: string
): Promise<TranscriptResponse> {
  const params: Record<string, string> = {};
  if (languages && languages.length > 0) {
    params.languages = languages.join(',');
  }

  const response = await apiClient.get(
    `/api/v1/youtube/videos/${videoId}/transcript`,
    {
      params,
      headers: buildYouTubeHeaders(apiKey),
    }
  );
  return response.data;
}

/**
 * 사용 가능한 자막 목록 조회
 */
export async function getAvailableTranscripts(
  videoId: string,
  apiKey?: string
): Promise<AvailableTranscript[]> {
  const response = await apiClient.get(
    `/api/v1/youtube/videos/${videoId}/transcripts/available`,
    { headers: buildYouTubeHeaders(apiKey) }
  );
  return response.data.transcripts || [];
}

/**
 * 자막 텍스트 파일로 다운로드
 */
export async function downloadTranscriptAsFile(
  videoId: string,
  videoTitle: string,
  languages?: string[]
): Promise<void> {
  try {
    const transcript = await getVideoTranscript(videoId, languages);

    // 텍스트 파일 생성
    const blob = new Blob([transcript.fullText], { type: 'text/plain;charset=utf-8' });
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `${videoTitle.replace(/[^a-z0-9]/gi, '_')}_transcript_${transcript.language}.txt`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(url);
  } catch (error) {
    console.error('자막 다운로드 실패:', error);
    throw error;
  }
}

/**
 * 채널 CII 점수 조회
 */
export async function getChannelCII(channelId: string): Promise<CIIMetrics> {
  const response = await apiClient.get(
    `/api/v1/youtube/channels/${channelId}/cii`
  );
  return response.data;
}

/**
 * 검색 히스토리 조회
 */
export async function getSearchHistory(): Promise<string[]> {
  const response = await apiClient.get('/api/v1/youtube/search-history');
  return response.data;
}

/**
 * 검색 히스토리 저장
 */
export async function saveSearchHistory(keyword: string): Promise<void> {
  await apiClient.post('/api/v1/youtube/search-history', { keyword });
}

/**
 * 검색 히스토리 삭제
 */
export async function deleteSearchHistory(keyword: string): Promise<void> {
  await apiClient.delete(`/api/v1/youtube/search-history/${keyword}`);
}
